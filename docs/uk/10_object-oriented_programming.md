# 10. Об'єктно-орієнтоване програмування

Об'єктно-орієнтоване програмування (ООП) в Ignis — це потужна парадигма, що дозволяє поєднувати дані та логіку для їх обробки в єдиній сутності під назвою **клас**. 
На відміну від структур, які є простими агрегаторами даних, класи є основним інструментом для інкапсуляції, успадкування та поліморфізму.

## Класи (`class`)

Клас є шаблоном для створення об'єктів. Він описує набір полів (даних) та методів (функцій), що належать цьому об'єкту.

### Оголошення класу

Клас оголошується за допомогою ключового слова `class`. 
Тіло класу може містити секції з модифікаторами доступу, запозиченими з C++:
- `public`: Поля та методи, доступні з будь-якого місця.
- `private`: Поля та методи, доступні лише всередині самого класу.
- `protected`: Поля та методи, доступні всередині класу та у його нащадках (буде розглянуто в темі успадкування).

```Ignis

// Гіпотетичний синтаксис
class Player {
    public:
        char id;

    private:
        int health;
        int mana;
}
```

## Методи

Методи — це функції, що належать класу і працюють з його даними. Їх реалізація в Ignis натхненна Rust та Python.

### Явний `self`

Подібно до Python, перший аргумент кожного методу екземпляра — це явне посилання на сам об'єкт. 
За конвенцією він називається `self`, проте може мати будь-яку назву. 
Його назва визначається у першому оголошеному методі, котрий за конвенцією є конструктором (`new`). 

### Реалізація методів (`impl`)

Реалізація методів винесена за межі оголошення класу, що, як і в Rust, робить код більш організованим. 
Для цього використовуються блоки `genimpl` та `impl`.
- `genimpl ClassName { ... }`: Блок для реалізації простих, неперевантажених методів.
- `impl MethodName in ClassName { ... }`: Спеціалізований блок для реалізації конкретного методу. 
   Він ідеально підходить для групування всіх його **перевантажених** версій.

```Ignis

class Vector2D {
    public:
        int x;
        int y;
}

// Загальна реалізація
genimpl Vector2D {
    // Конструктор (ініціалізатор)
    void new(ptr Vector2D self, int start_x, int start_y) {
        self.x = start_x;
        self.y = start_y;
    }

    // --- СТАТИЧНИЙ МЕТОД ---
    // Цей метод не приймає 'self', бо він не працює з конкретним
    // екземпляром, а створює новий за готовим шаблоном.
    ptr Vector2D zero() {
        // Він використовує загальнодоступний конструктор new()
        return new Vector2D(0, 0);
    }

    // Метод екземпляра
    int length_sqr(ptr Vector2D self) {
        return self.x * self.x + self.y * self.y;
    }
}

// Реалізація перевантаженого методу 'add'
impl add in Vector2D {
    // 1. Додавання іншого вектора
    void add(ptr Vector2D self, ptr Vector2D other) {
        self.x = self.x + other.x;
        self.y = self.y + other.y;
    }

    // 2. Додавання скалярного значення
    void add(ptr Vector2D self, int scalar) {
        self.x = self.x + scalar;
        self.y = self.y + scalar;
    }
}
```

## Життєвий цикл об'єкта

Керування створенням та знищенням об'єктів є явним і інтегрованим із системою "Вахтера". 
Ignis використовує спеціальні дандер-методи для ініціалізації та фіналізації об'єктів.

### Створення та ініціалізація (`new` та `::new()`)
Створення об'єкта — це двокроковий процес, керований оператором new, який працює подібно до конструкторів у Python:
- `new ClassName(...)`: Оператор new дає команду "Вахтеру" виділити пам'ять під новий, порожній об'єкт.
- `::new(...)`: Одразу після виділення пам'яті на цьому об'єкті автоматично викликається спеціальний метод-ініціалізатор `::new()`. 
   Його завдання — заповнити поля об'єкта початковими значеннями.

Метод `::new` не повертає значення. Його єдина мета — налаштувати `self`.
```Ignis

class Vector2D {
    public:
        int x;
        int y;
}

genimpl Vector2D {
    // Метод-ініціалізатор (конструктор)
    void new(ptr Vector2D self, int start_x, int start_y) {
        self.x = start_x;
        self.y = start_y;
    }
}

// Оператор 'new' створює об'єкт і неявно викликає new
mut ptr Vector2D my_vector = new Vector2D(10, 20);
print(my_vector.x); // Виведе 10
```

Такий підхід поєднує явне керування пам'яттю (`new`) з автоматизацією ініціалізації (`::new`), що робить процес створення об'єктів одночасно контрольованим та зручним.

Неймінг може спершу дещо плутати, однак він задуманий для стертя границі між створенням та ініціалізацією об'єкта для кінцевого користувача (програміста).

### Знищення об'єкта (Деструктори)

Коли об'єкт знищується за допомогою оператора `free`, перед звільненням пам'яті автоматично викликається його деструктор. 
За конвенцією, це дандер-метод `__del__`. Це дає об'єкту можливість звільнити будь-які ресурси, якими він володіє.
```Ignis

genimpl Vector2D {
    // Деструктор
    void __del__(ptr Vector2D self) {
        // Логіка очищення, якщо потрібна
        print_string("Vector2D destroyed!");
    }
}

// ...
free(my_vector); // Викличе __del__ перед звільненням пам'яті
```

## Дандер-методи
Для інтеграції з операторами мови (наприклад, `+`, `==`, `===`) використовуються спеціальні дандер-методи (від англ. "double underscore"), як у Python. Вони завжди є публічними.
- `__add__(self, other)`: для оператора `+`.
- `__eq__(self, other)`: для оператора `==`.
- `__eqt__(self, other)`: для оператор `===`.
- та інші.

Це дозволяє об'єктам поводитись як вбудовані типи.


// TODO: Захищені та приватні методи.

// TODO: Створити повний список дандер-методів та розмістити його тут.