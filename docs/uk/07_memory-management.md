# 7. Керування динамічною пам'яттю: "Вахтер та Ключі"
Керування пам'яттю в Ignis побудовано на унікальній гібридній моделі. Вона поєднує явний контроль над життєвим циклом об'єктів, як у C++, з гарантіями безпеки під час виконання, натхненними Rust. Мета — усунути такі небезпечні помилки, як висячі вказівники, залишаючи програмісту контроль над пам'яттю.

## Філософія: Вахтер та Ключі
В основі системи лежить проста аналогія:

- **"Вахтер" (Рантайм)**: Єдина сутність, яка володіє всією динамічно виділеною пам'яттю ("будинком"). Вона веде детальний журнал всіх об'єктів ("квартир") та посилань на них ("ключів").

- **Змінні ("Ключі")**: Змінні, що вказують на об'єкти в пам'яті, є "ключами". Вони не володіють даними, а лише надають до них доступ.

## Основні принципи
### Життєвий цикл об'єкта
Програміст повністю контролює, коли створювати та знищувати об'єкти в динамічній пам'яті (купі). 
Цей процес тісно інтегрований з конструкторами та деструкторами класів.

#### Створення (`new`)
Оператор new дає команду "Вахтеру" виділити пам'ять під новий об'єкт та ініціалізувати його.

Процес відбувається так:

1. "Вахтер" виділяє необхідний обсяг пам'яті.
2. Викликається статичний метод-конструктор класу (за конвенцією `::new()`), який ініціалізує цю пам'ять.
3. "Вахтер" реєструє новий об'єкт і видає програмісту перший "ключ" (вказівник).

```Ignis

// Синтаксис є гіпотетичним
// 1. "Вахтер" виділяє пам'ять і викликає Player::new().
// 2. Нам видається "ключ власника" `p1`.
mut ptr Player p1 = new Player('P');
```

#### Знищення (`free`)

Оператор free дає команду "Вахтеру" коректно знищити об'єкт та анулювати всі ключі, пов'язані з ним.

Процес знищення:

1. Викликається **деструктор** об'єкта (наприклад, дандер-метод `__del__`). Це дозволяє об'єкту звільнити будь-які ресурси, 
    якими він володіє (наприклад, закрити файли або викликати free для внутрішніх об'єктів).
2. "Вахтер" анулює всі ключі, що посилаються на цей об'єкт.
3. "Вахтер" звільняє пам'ять, яку займав об'єкт.

```Ignis

// Даємо команду "Вахтеру" запустити процес знищення.
free(p1);
```

**Важливо**: Якщо `free` не було викликано, об'єкт та пам'ять, яку він займає, залишаться до кінця роботи програми. Це може призвести до витоків пам'яті.

### 2. Змінні як "Ключі"
Присвоєння змінних, що вказують на об'єкти в купі, не копіює об'єкт, а створює новий "ключ" (посилання) до того ж самого об'єкта.

```Ignis

mut Point p1 = new Point;

// "Вахтер" створює новий ключ `p2`, який веде до того ж об'єкта.
// Копіювання не відбувається.
Point p2 = p1;
```

### 3. Типи ключів та дозволи
Існує два типи "ключів", що визначають права доступу до об'єкта:

- **Ключ Власника (Owner Key):** Перша змінна, якій присвоюється новостворений об'єкт. Цей ключ має повні права на читання та запис.

- **Гостьовий Ключ (Guest Key):** Будь-який ключ, створений через просте присвоєння (p2 = p1). За замовчуванням, він має право лише на читання.

Для створення нового ключа з повними правами на запис буде введено спеціальну властивість (наприклад, permall).

## Гарантії безпеки (Перевірки під час виконання)
"Вахтер" забезпечує безпеку, перевіряючи всі операції з ключами під час виконання програми.

Запобігання "висячим вказівникам"
Це ключова особливість системи. Коли програміст викликає free(p1):

1) "Вахтер" знаходить об'єкт, на який вказує p1.

2) Він переглядає свій журнал і знаходить всі інші ключі (p2, p3...), що вказують на цей об'єкт.

3) Він анулює всі ці ключі.

4) Лише після цього він звільняє пам'ять.

Будь-яка подальша спроба використати анульований ключ (p2) призведе до контрольованої помилки часу виконання (напр., "Спроба доступу за недійсним посиланням"), а не до невизначеної поведінки чи падіння програми.
