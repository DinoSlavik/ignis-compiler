# 6. Функції та Блоки коду
Функції є основним способом організації та повторного використання коду в Ignis. 
Вони підтримують такі механізми, як перевантаження та неявне повернення значень. 
Крім того, мова підтримує вирази-блоки, які дозволяють створювати складні вирази, що повертають значення.

## Оголошення функцій
Функції оголошуються із зазначенням типу значення, що повертається, імені, списку параметрів у дужках та тіла функції у фігурних дужках `{}`.

```Ignis

// Функція, що приймає два цілих числа і повертає їх суму
int add(int a, int b) {
    a + b // Значення цього виразу буде повернуто
}
```

Точкою входу в будь-яку програму на Ignis є функція main, яка повинна повертати `int`.

### Неявне повернення значення (Implicit Return)
Подібно до `if`, тіло функції є виразом. Якщо в кінці тіла функції стоїть вираз без крапки з комою `;`, його значення автоматично повертається з функції.

```Ignis

int get_version() {
    42 // Немає ';', тому 42 повертається з функції
}
```

### Ключове слово return
Для явного повернення значення з будь-якого місця у функції (наприклад, для раннього виходу) використовується ключове слово `return`.

```Ignis

int check_score(int score) {
    if (score < 0) {
        return -1; // Ранній вихід з функції з кодом помилки
    }
    // ... подальша логіка
    score
}
```

## Перевантаження функцій
Ignis дозволяє визначати кілька функцій з однаковим іменем, але різними параметрами. 
Цей механізм називається **перевантаженням**. 
Унікальною особливістю мови є те, що перевантаження можливе не лише за типами аргументів, а й за їхніми іменами.

Це дозволяє створювати API, що є більш семантично виразними та читабельними.

```Ignis

// Дві версії функції для встановлення позиції
// Перша приймає декартові координати
set_position(int x, int y) { ... }

// Друга, з тими ж типами, але іншими іменами, приймає полярні координати
set_position(int r, int phi) { ... }
```

### Вирішення неоднозначності
Якщо компілятор може обрати версію функції лише за типами, він зробить це автоматично. 
Однак, якщо існує неоднозначність (як у прикладі вище, де обидві функції приймають `int`, `int`), 
компілятор вимагатиме від програміста явно вказати імена аргументів під час виклику.

```Ignis

mut Point my_point;

// Неоднозначний виклик - Помилка компіляції!
// my_point.set_position(10, 20);

// Явний виклик з іменованими аргументами - Все гаразд
my_point.set_position(x: 10, y: 20);
my_point.set_position(r: 5, phi: 90);
```

Для авторів бібліотек планується **властивість** `default`, 
яка дозволить позначати одну з неоднозначних версій як версію за замовчуванням, 
щоб уникнути поломки коду користувачів при додаванні нових перевантажень.

## Вирази-блоки
Будь-який блок коду, оточений фігурними дужками `{}`, може бути використаний як вираз. Такий блок виконує всі інструкції всередині себе, а його результатом стає значення останнього виразу в блоці (того, після якого не стоїть крапка з комою).

Це надзвичайно потужний інструмент для ініціалізації змінних зі складною логікою.

```Ignis

int main() {
    int y = {
        mut int z = 10 + 5; // z = 15
        z = z + 20;         // z = 35
        z                   // Немає ';', це значення повертається з блоку
    };
    print(y); // Повинно вивести 35

    // Неявний return з main
    0
}
```

## Вбудовані функції
Ignis надає невеликий набір вбудованих функцій для базових операцій вводу-виводу.

- `print(int value)`: Виводить 64-бітне ціле число та переводить рядок. 

- `putchar(char value)`: Виводить один символ у потік виводу. 

- `getchar()`: Читає один символ з потоку вводу та повертає його.

