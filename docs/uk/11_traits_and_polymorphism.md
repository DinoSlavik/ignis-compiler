# 11. Трейти та Поліморфізм
В Ignis, на відміну від мов з класичним успадкуванням, гнучкість коду досягається не через складні ієрархії класів, 
а через трейти. Трейт — це механізм, запозичений з Rust, який дозволяє визначати спільну поведінку для різних типів.

## Що таке Трейт?
Трейт (англ. `trait` — риса, характеристика) — це, по суті, **контракт поведінки**. 
Він оголошує набір методів, які певний тип даних повинен реалізувати, але не надає їхньої реалізації. 
Трейт є аналогом **інтерфейсу** в інших мовах.

Основна ідея трейтів — **відокремити визначення поведінки від її конкретної реалізації**. Ц
е дозволяє писати код, який працює з будь-якими типами, що дотримуються одного контракту, 
не знаючи нічого про їхню внутрішню структуру.

## Оголошення трейту
Трейт оголошується за допомогою ключового слова trait та містить список сигнатур методів (їхні імена, параметри та тип повернення).

```Ignis

// Оголошуємо контракт для всього, що може бути намальовано на екрані
trait Drawable {
    // Будь-який тип, що реалізує Drawable, повинен мати цей метод
    void draw(ptr self);
}
```

## Реалізація трейту

Щоб клас міг використовувати трейт, він має його **реалізувати**. Цей процес складається з двох частин:
1. **Оголошення реалізації**: У заголовку класу після його імені та списку батьківських класів (якщо є) 
   використовується ключове слово `implements`, за яким слідує список трейтів.
2. **Надання реалізації**: Методи, оголошені в трейті, повинні бути реалізовані в блоці `impl` для цього класу.

```Ignis

// Створюємо два абсолютно різні класи
class Player { public: char id; }
class Button { public: string text; }

// --- Реалізація для класу Player ---

// 1. Оголошуємо, що Player буде реалізовувати трейт Drawable
class Player implements Drawable {

    // 2. Надаємо конкретну реалізацію методу draw
    impl draw in Player {
        void draw(ptr Player self) {
            // ... логіка малювання гравця ...
            putchar(self.id);
        }
    }

}


// --- Реалізація для класу Button ---
class Button implements Drawable {

    impl draw in Button {
        void draw(ptr Button self) {
            // ... логіка малювання кнопки ...
            print_string(self.text);
        }
    }

}
```

_Примітка: Через збільшену кількість вкладеностей код стає менш читабельним, тож рекомендується писати це у наступному форматі:_ 
```Ignis

class ClassName { ... }

class ClassName implements TraitName {
impl trait_method1 in ClassName {
    
    void trait_method1( ... ) { 
        ... 
    }
    
    void trait_method1( ... ) { 
        ... 
    }
    
    void trait_method1( ... ) { 
        ... 
    }
}

impl trait_method2 in ClassName {
    
    int trait_method2( ... ) { 
        ... 
    }
}}
```

## Поліморфізм: Сила трейтів

Головна перевага трейтів розкривається, 
коли ми починаємо використовувати їх для досягнення поліморфізму — можливості працювати з об'єктами різних типів через єдиний інтерфейс. 

Функція може приймати параметр, тип якого є не конкретним класом, а трейтом. 
Це означає, що у цю функцію можна передати будь-який об'єкт, клас якого реалізує цей трейт.

```Ignis

// Ця функція не знає, що саме вона малює - гравця, кнопку чи щось інше.
// Вона лише знає, що об'єкт ГАРАНТОВАНО має метод draw().
void render_object(ptr Drawable obj) {
    obj.draw();
}

int main() {
    mut ptr Player p = new Player();
    p.id = 'P';

    mut ptr Button b = new Button();
    b.text = "[OK]";

    // Ми можемо передати об'єкти абсолютно різних типів
    // в одну й ту саму функцію, бо вони обидва реалізують трейт Drawable.
    render_object(p);
    render_object(b);

    free(p);
    free(b);
    return 0;
}
```
