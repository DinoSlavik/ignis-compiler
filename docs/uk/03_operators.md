# 3. Оператори
Ignis надає багатий набір операторів для виконання арифметичних, логічних та побітових операцій, а також для порівняння значень.

## Арифметичні оператори
Це базові оператори для математичних обчислень.

- `+` : Додавання

- `-` : Віднімання

- `*` : Множення

- `/` : Ділення

```Ignis

int result = 20 + 10; // result = 30
int result = 20 - 10; // result = 10
int result = 20 * 10; // result = 200
int result = 20 / 10; // result = 2
```

_Примітка: Поведінка при діленні на нуль (0) наразі не визначена і може призвести до помилки часу виконання._

// TODO: Визначити поведінку для ділення на нуль. `inf`, коли буде додано, вірогідно буде доступне для кожного з типів, у тому числі `-inf`, для типів, що підтримують від'ємні значення. А себто можна зробити результатом саме `inf`.

## Оператори порівняння
Використовуються для порівняння двох значень. Результатом є `1` (істина) або `0` (хиба).

- `==` : Дорівнює

- `!=` : Не дорівнює

- `<` : Менше

- `<=` : Менше або дорівнює

- `>` : Більше

- `>=` : Більше або дорівнює

```Ignis

print(20 == 10); // Виведе 0
print(20 != 10); // Виведе 1
print(20 < 10);  // Виведе 0
print(10 <= 10); // Виведе 1
print(20 > 10);  // Виведе 1
print(15 >= 15); // Виведе 1
```

## Логічні оператори
Ці оператори працюють зі значеннями "істина" (не нульове число) та "хиба" (0).

- `and` : Логічне "І"

- `or` : Логічне "АБО"

- `not` : Логічне "НЕ"

- `xor` : Виключне "АБО"

- `nand`, `nor`, `xnor`: Інвертовані версії відповідних операторів (`NOT AND`, `NOT OR` і `NOT XOR`).

- `nnot`: Буленізатор. Перетворює будь-яке не нульове число у `1`, а нуль (`0`) у `0`.

```Ignis

// Звичайні логічні оператори
print(1 and 0);   // Виведе 0
print(1 or 1);    // Виведе 1
print(not 0);     // Виведе 1
print(1 xor 1);   // Виведе 0

// Інвертовані логічні оператори
print(1 nand 0);  // Виведе 1
print(1 nor 1);   // Виведе 0
print(nnot 25);    // Виведе 1
print(nnot -25);    // Виведе 1
print(nnot 0);    // Виведе 0
print(1 nxor 1);  // Виведе 1
```

_Примітка: nnot був створений заради жарту, а також, оскільки "це можна було зробити", однак виявився насправді корисним._

//TODO: `nnot` має приймати будь-яке число на вході (як і усі інші логічні оператори), проте на виході давати лише `0` або `1`, себто бути чимось на кшталт перетворювача у бінарну логіку.

## Побітові оператори
Ці оператори виконують маніпуляції на рівні окремих бітів числа.

- `band` : Побітове "І"

- `bor` : Побітове "АБО"

- `bnot` : Побітова інверсія (`NOT`)

- `bxor` : Побітове виключне "АБО"

- `nband`, `nbor`, `nbxor`: Інвертовані версії.

- `nbnot`: Побітове подвійне заперечення (не змінює значення).

```Ignis

// Для простоти, уявимо, що працюємо лише із чотирибітовими додатніми числами*
// На практиці у випадку 'int' це будуть 64-бітові числа із знаком
// 5 це 0101, 3 це 0011
// Звичайні побітові оператори
print(5 band 3); // Виведе 1 (0001)
print(5 bor 3);  // Виведе 7 (0111)
print(bnot 3);   // Виведе 12 (1100)
print(5 bxor 3); // Виведе 6 (0110)

// Інвертовані побітові оператори
print(5 nband 3); // Виведе 14 (1110)
print(5 nbor 3);  // Виведе 8 (1000)
print(nbnot 3);   // Виведе 3 (0011)
print(5 nbxor 3); // Виведе 9 (1001)
```

*`nbnot` є аналогом `nnot` тут, з аналогічною історією, однак поки що без щасливого кінця.*

## Спеціальні оператори
- `=` : Присвоєння значення.

- `===` : Порівняння типів. Цей оператор працює на етапі компіляції і повертає `1`, якщо типи операндів однакові, і `0` в іншому випадку.

```Ignis

int a = 10;
// 'a' та літерал '20' мають однаковий тип 'int'
int result = a === 20;
print(result); // Виведе 1

char b = 'Q';
// Однак 'b' має тип 'char', що є відмінним від типу 'a' ('int')
print(b === a); // Виведе 0 
```

## Перевантаження операторів

У користувацьких типах усі оператори можна перевантажувати. 
За замовчуванням імплементовані лише `=`, `===` та `==`, `!=` (за принципом порівняння адреси у пам'яті).

// QUES: Є нюанс, char це, де-факто, особливий підтип int, а тому з'являється логічне питання: як оператор === реагуватиме на підтипи, коли їх порівнюють із батьківськими типами? Можливо, він строго перевіряє, а ми додамо ще якийсь оператор, типу аналог пайтонівського isinstance, котрий буде вже перевіряти не просто ідентичність типів, а і те, чи є цей тип підтипом? Себто у цьому випадку === поверне нам при порівнянні 'char' та 'int' нулик, а наш умовний is (назва буде інша, логічніша) поверне одиничку, оскільки хоч і унікальний, проте 'char' то є своєрідний 'int'? Ну і також питання тоді у тім, а наскільки взагалі є чесно робити вбудовані типи за такою схемою та чим, до прикладу, буде 'string', котра є одночасно і списком, але і списком (я не пам'ятаю термінологію по масивам) 'char'? Себто це одночасно і список, і символ, ціле число, якщо дивитися через цей оператор? Це треба буде вирішити. А також поведінка всіх цих операторів матиме перезаписуватися явно, і там здається у мене навіть були ідеї на тему того, як це зробити.

// ANSV1: Вірогідно все ж `===` буде перевіряти буквально "чи є ці типи однаковими?", 
а новий оператор, наприклад `ischild(child, parent)`, відповідно рекурсивно перевірятиме як раз на спадковість.

// TODO: Додати таблицю пріоритетів операторів.