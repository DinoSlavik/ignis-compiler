# 4. Керування потоком виконання
Ignis надає гнучкі інструменти для керування потоком виконання вашої програми, включаючи умовні конструкції та різноманітні цикли.

## Умовні конструкції if-elif-else
Однією з ключових особливостей Ignis є те, що конструкція `if` може використовуватись і як інструкція (`statement`) для виконання дій, і як вираз (`expression`), що повертає значення.

### Використання if як виразу
Коли if використовується як вираз, він завжди повертає значення. Блок коду, що відповідає умові, яка спрацювала, повертає значення свого останнього виразу.

```Ignis

int a = 10;
int b = 20;

// 'if' використовується для визначення значення змінної 'max_val'
int max_val = if (a > b) {
    a // Повертається 'a'
} else {
    b // Повертається 'b'
};

print(max_val); // Виведе 20
```

Конструкція `if` може включати `elif` (`else if`) для перевірки кількох умов послідовно.

```Ignis

int score = 85;
int grade = if (score >= 90) {
    5
} elif (score >= 80) {
    4
} else {
    3
};
print(grade); // Виведе 4
```

### Використання if як інструкції
Коли значення, що повертає `if`, не присвоюється змінній, конструкція працює як традиційна інструкція, просто виконуючи код у відповідному блоці.

```Ignis

mut int a = 25;
if (a > 20) {
    print(a); // if використовується для виконання дії, значення ігнорується
}
```

### Тернарний-подібний вираз
Ignis також підтримує більш компактний синтаксис для простих умов, схожий на тернарний оператор в інших мовах.

```Ignis

int score = 85;
// Синтаксис: <значення_якщо_істина> if <умова> else <значення_якщо_хиба>
int is_passing = 1 if score >= 60 else 0;
print(is_passing); // Виведе 1
```

Примітка: Чисто ідейно це є просто скороченням від звичайного виразового розгалуження.

## Цикли
У мові є декілька види циклів для різних сценаріїв.

### Цикл for
Ignis використовує C-подібний синтаксис для циклу `for`, який складається з ініціалізатора, умови та інкременту.

```Ignis

// Цикл від 0 до 4 включно
for (mut int i = 0; i < 5; i = i + 1) {
    print(i);
}
```

### Цикл foreach
Є ідейно обгорткою циклу `for` для ітерування по колекціям та генераторам.
Цей цикл наразі запланований як такий, що проходиться строго від першого до останнього елементу,
без можливості задання інкрементора. Можливо, це можна буде дещо спростити потенційною наявністю слайсів.

Наразі не реалізований.

Має синтаксис `foreach (item(-s); collection) { [code] }`, де: 

- `item(-s)` — один або декілька (у випадку колекції колекцій) елементів, що відповідають поточному індексу;
- `collection` — об'єкт колекційного або підходящого користувацького типу;
- `[code]` — ваш код у тілі цикла

Деякі приклади:

```Ignis

// Цикл, що проходиться по кожному елементі у кортежі
tuple int prime_numbers = [1, 2, 3, 5, 7, 11, 13, 17, 19, 23]

foreach (int num; prime_numbers) {
    print(num);
}

// Проходи по колекції, пропускаючи всі окрім першого, всі окрім останнього та певні елементи у індексі
// Це абстрактний код, оскільки ще не визначено як саме будуть створюватися змінні-колекції
tuple tuple int some_numbers = [[0, 1, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]] 

foreach (first, __; some_numbers) {
    print(first);
}

foreach (__, last; some_numbers) {
    print(last);
}

foreach (_, second, _; some_numbers) {
    print(second);
}
```

_Примітка: `_` пропускає лише один елемент, у той час як `__` пропускає усі елементи від того, 
замість якого він написаний, аж до наступного "вибраного" елементу (у цих прикладах це `first`, `second`, `last`) 
або до кінця, якщо до нього не було вибрано жодного елементу. Якщо на дорозі `__` трапляється інший `__` або `_` 
вони просто ігноруються, хоч це є і небажаним синтаксисом та виклече попередження від компілятора._

### Цикл forin
Фактично загальніший варіант циклу `foreach`, на який поширюються ті ж правила, окрім самого способу ітерування.
З цієї причини зазначена лише декларація циклу.

За замовчуванням інкрементор неявно не може виходити за межі розміру колекції, 
проте за протреби цю поведінку можна змінити передаючи як правило.

Наразі не реалізований.

Має синтаксис `foreach (index declaration; item(-s); collection; incremention rule) { [code] }`, де: 

- `index declaration` — задання початкового індексу.
- `item(-s)` — один або декілька (у випадку колекції колекцій) елементів, що відповідають поточному індексу;
- `collection` — об'єкт колекційного або підходящого користувацького типу;
- `incremention rule` — вираз, що описує крок індексу. Також дозволяються функції (що приймають як аргумент ціле число та повертають ціле число).
- `[code]` — ваш код у тілі циклу

Деякі приклади:

```Ignis
   
    // Класичний та зворотній прохід 
    forin (mut int i = 0; item1, item2; collection; i += 2) { ... }
    forin (mut int i = -1; item1, item2; collection; i -= 2) { ... }
    
    // Використання багаторядкового виразу як правила 
    forin (
        mut int i = 0; 
        item; collection;
        {
            if ( i % 2 == 0 ) { 2 * i }
            else { i - 3 }
        }
    ) { ... }
    
    // Заздалегіть оголошений індекс та використання функції-правила
    int increment(int i) {
        return i + 1;
    }
    mut int i = 0;
    
    forin (i; item; collection; increment(i)) { ... }
```

Примітка: у деяких випадках може бути дещо повільнішим відносно `for` та `foreach`, 
однак у цілях зручності та читабельності для ітерації по колекціях рекомендується використовувати його. 

### Цикл while
Цикл `while` виконує блок коду, доки його умова залишається істинною.

```Ignis

mut int i = 0;
while (i < 5) {
    print(i);
    i = i + 1;
}
```

### Цикл loop
Цикл `loop` створює нескінченний цикл. Вихід з такого циклу зазвичай здійснюється за допомогою ключового слова `break`.

```Ignis

mut int i = 0;
loop {
    i = i + 1;
    print(i);
    if (i >= 5) {
        break; // Вихід з циклу
    }
}
```

### Керування циклами: break та continue
- `break`: Негайно завершує виконання поточного циклу (`for`, `while`, `loop`).

- `continue`: Пропускає решту поточної ітерації та переходить до наступної.

// QUES: Можливо, додати окремий цикл forin для проходки по елементам якогось масиву? Ну в плані замість конструкції типу "for item in array" додати окремий "forin (\<iterator\>, \<incrementor\>, \<object to iterate\>, \<optionaly limit (or maybe rules?) for iterator\>) {}".

