# 12. Ітератори та Генератори

Для ефективної роботи з послідовностями даних, особливо з дуже великими або нескінченними, Ignis надає два потужні механізми: генератори та протокол ітерації. Вони дозволяють реалізувати "ліниві" обчислення, коли кожен наступний елемент послідовності генерується лише тоді, коли він справді потрібен.

## Проблема: "Жадібні" колекції
Традиційні колекції, такі як масиви, зберігають усі свої елементи в пам'яті одночасно. Це зручно для невеликих обсягів даних, але якщо нам потрібна послідовність з мільйона чисел, зберігати її всю в пам'яті — неефективно.

## Генератори: Фабрики значень "на льоту"
Найпростіший спосіб створити "ліниву" послідовність в Ignis — це написати функцію-генератор. Це спеціальна функція, яка може "призупиняти" своє виконання і "віддавати" значення назовні, а потім відновлювати роботу з того ж місця.

### Ключове слово yield
Замість return генератори використовують ключове слово `yield` (англ. "вродити", "виробити").
- `yield <значення>`: Призупиняє виконання функції, повертає `<значення>` назовні (наприклад, циклу `foreach`), і зберігає свій поточний стан.
- При наступному зверненні до генератора він відновлює роботу з рядка, наступного за `yield`. Коли у генераторі більше немає операторів `yield`, послідовність вважається завершеною.

### Приклад: Генератор чисел Фібоначчі
Замість того, щоб зберігати мільйон чисел у масиві, ми можемо написати генератор, який обчислює їх "на льоту", не використовуючи зайвої пам'яті.

```Ignis

// Ця функція є генератором, бо використовує 'yield'.
// Вона повертає спеціальний об'єкт-генератор.
ptr Generator fibonacci(int limit) {
    mut int a = 0;
    mut int b = 1;

    while (a < limit) {
        yield a; // 1. Віддати поточне значення і "заснути"
        mut int temp = a;
        a = b;
        b = temp + b;
    }
}
```

## Протокол ітерації та цикли
Щоб об'єкт можна було перебрати в циклі, він має підтримувати відповідний протокол, реалізований через дандер-методи.

### Цикл `foreach` та `__next__`
Простий цикл `foreach` призначений для послідовного перебору елементів. 
Він працює з будь-яким об'єктом, що має метод `__next__`. Функції-генератори автоматично повертають такий об'єкт.

Цикл foreach під капотом просто викликає `__next__()` знову і знову, доки генератор не завершить свою роботу.
```Ignis

int main() {
    // Цикл foreach працює з генератором, отримуючи значення по одному
    foreach (num, fibonacci(100)) {
        print(num); // Виведе: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89
    }
    return 0;
}
```

### Цикл `forin` та `__idx__`

Більш складний цикл `forin` призначений для ітерації з контролем індексу. 
Він працює з колекціями, що підтримують доступ до елементів за індексом через дандер-метод `__idx__` 
та `__len__` для визначення розміру.

```Ignis

// Цей цикл буде працювати з масивами та іншими індексованими колекціями
forin (mut int i = 0; my_array; item; i = i + 1) {
    // ... тіло циклу ...
}
```

// QUES: Альтернативний підхід до ітерації міг би базуватися на трейтах, а не на дандер-методах. Наприклад, можна було б визначити трейт Iterable з методом next(). Будь-який клас або генератор, що реалізує цей трейт, міг би використовуватися в циклах. Це зробило б систему ітерації більш формалізованою та розширюваною, але могло б вимагати складніших типів, таких як Option<T> для позначення кінця послідовності. Цю ідею варто обдумати для майбутніх версій мови.