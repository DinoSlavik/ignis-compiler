/*
 * Ignis: Комплексний тест для Фази 2
 * * Цей файл перевіряє більшість реалізованих можливостей мови:
 * - Глобальні константи та структури
 * - Функції, що приймають вказівники на структури
 * - Різноманітні оператори (логічні, побітові, порівняння)
 * - Виразо-орієнтовані if/elif/else та блоки
 * - Цикли for, while, loop з break та continue
 * - Роботу з вказівниками (addr, deref)
 * - Оператор порівняння типів (===)
 * - Базове введення/виведення
 */

const int WORLD_VERSION = 42;

struct Vector2D {
    int x;
    int y;
}

struct GameObject {
    ptr Vector2D position;
    char id;
}

// Перевірка логічних та побітових операторів
int test_operators(int a, int b) {
    print(a and b); // 1
    print(a or 0);  // 1
    print(a xor b); // 0 (1 xor 1)

    // 5 (0101) band 12 (1100) = 4 (0100)
    int bitwise_res = 5 band 12;
    print(bitwise_res); // 4

    return (a === b); // Повинно повернути 1, бо обидва int
}

// Робота зі структурами через вказівники
void move_game_object(ptr GameObject obj, int dx, int dy) {
    // Доступ до полів через вказівник (->)
    obj.position.x = obj.position.x + dx;
    obj.position.y = obj.position.y + dy;
}

int main() {
    print(123456789); // Test print
    putchar('\n');

    // 1. Тест констант, змінних та операторів
    mut int score = 100;
    score = score - WORLD_VERSION; // 100 - 42 = 58
    print(score);
    putchar('\n');
    print(test_operators(1, 1)); // Повинно вивести 1, 1, 0, 4, 1
    putchar('\n');

    // 2. Тест циклу for та expression-based if/elif/else
    for (mut int i = 0; i < 5; i = i + 1) {
        int category = if (i == 0) {
            99  // Zero category
        } elif (i - (i / 2) * 2 == 0) { // <--- ВИПРАВЛЕНО: i % 2 == 0
            2   // Even
        } else {
            1   // Odd
        };
        print(category); // 99, 1, 2, 1, 2
    }
    putchar('\n');

    // 3. Тест структур, вказівників, addr та deref
    mut Vector2D player_pos;
    player_pos.x = 10;
    player_pos.y = 20;

    mut GameObject player;
    player.position = addr player_pos;
    player.id = 'P';

    print(player.position.x); // 10
    move_game_object(addr player, 5, -5);
    print(player_pos.x); // 15
    print(player_pos.y); // 15
    putchar('\n');

    // 4. Тест циклу loop та expression-based block
    mut int countdown = 3;
    loop {
        if (countdown == 0) { break; }

        int block_val = {
            print(countdown); // 3, 2, 1
            countdown = countdown - 1;
            countdown * 10 // Повертаємо значення
        };
        print(block_val); // 20, 10, 0
    }
    putchar('\n');

    /*
    // ==========================================================
    // == Майбутній тест для Фази 2: Керування пам'яттю        ==
    // ==========================================================
    // Цей код не буде працювати, доки не буде реалізовано
    // динамічне виділення пам'яті та "Вахтер".

    // 1. Створення об'єкта в купі
    // ptr GameObject enemy = new GameObject;

    // 2. Ініціалізація полів
    // deref enemy.id = 'E';
    // deref enemy.position = new Vector2D;
    // deref deref enemy.position.x = 100;
    // deref deref enemy.position.y = 100;

    // 3. Створення "гостьового ключа"
    // ptr GameObject another_ref = enemy;

    // 4. Використання
    // move_game_object(enemy, 10, 10);
    // print(deref deref another_ref.position.x); // Повинно вивести 110

    // 5. Звільнення пам'яті
    // free(deref enemy.position); // Звільняємо вкладений об'єкт
    // free(enemy); // Звільняємо основний об'єкт

    // 6. Перевірка безпеки "Вахтера"
    // Спроба доступу через 'another_ref' повинна викликати помилку рантайму,
    // а не segmentation fault.
    // print(deref another_ref.id); // Runtime Error: Attempt to access dangling pointer
    */

    print(1337);
    putchar('\n');

    return 0;
}