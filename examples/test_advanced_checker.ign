// ===================================================================
// ### TEST BLOCK FOR STEP 2: StructDef ###
// ===================================================================

//// Помилка SE001: Повторне оголошення структури
//struct Point { int x; };
//struct Point { int y; }; // ERROR: Struct 'Point' is already defined.
//
//// Помилка SE002: Повторне оголошення поля в структурі
//struct Transform {
//    int scale;
//    int position;
//    int position; // ERROR: Duplicate field 'position' in struct 'Transform'.
//};
//
//
//
//int main() {
//    return 0;
//}

// ===================================================================
// ### TEST BLOCK FOR STEP 3: VarDecl and Assign ###
// ===================================================================

//struct TestPoint {
//    int x;
//    int y;
//};
//
//int main() {
//    // --- "Happy Path" - Коректні оголошення та присвоєння ---
//    int a = 10;
//    mut int b = 20;
//    b = a; // OK: присвоєння int до mut int
//
//    char c = 'A';
//    mut char d = 'B';
//    d = c; // OK
//
//    mut TestPoint p1;
//    p1.x = 100; // OK: присвоєння полю структури
//    p1.y = 200;
//
//    TestPoint p2 = p1; // OK: присвоєння структури (копіювання)
//
//    // --- Перевірка помилок (цей код не повинен компілюватися) ---
//
//    // SE004: Повторне оголошення змінної
////    int a = 99;
//
//    // SE007: Невідповідність типів при оголошенні
////    int type_mismatch = 'c';
//
//    // SE007: Невідповідність типів при присвоєнні
//    // b = c;
//
//    // SE009: Спроба присвоєння немутабельній змінній
////    int immutable_var = 50;
////    immutable_var = 60;
//
//    // SE008: Спроба присвоєння не l-value
////    100 = a;
//
//    // SE003: Використання неоголошеної змінної
////     a = not_defined_variable;
//
//    // SE006: Доступ до неіснуючого поля структури
////     p1.z = 300;
//
//    // SE005: Спроба доступу до поля у не-структури
////     a.x = 10;
//
//    return 0;
//}

// ===================================================================
// ### TEST BLOCK FOR STEP 3: BinOp and UnaryOp ###
// ===================================================================

struct DummyStruct {
    int value;
};

int main() {
    // --- "Happy Path" - Коректні операції ---
    int a = 10 + 5 * 2; // 20
    int b = a / 4;      // 5
    char c = 'A' + 1;   // OK: char та int

    int is_equal = (a == 20);      // 1 (true)
    int is_not_equal = ('a' != 'b'); // 1 (true)

    mut ptr DummyStruct s_ptr;
    deref s_ptr; // OK: розіменування вказівника
    addr a;       // OK: взяття адреси змінної

    // --- Перевірка помилок (цей код не повинен компілюватися) ---

    mut DummyStruct s_instance;

    // SE010: Арифметика над невідповідними типами
    // int res = a + s_instance;

    // SE011: Порівняння різних типів
    // int cmp = (a == s_instance);

    // SE013: Логічне "НЕ" над структурою
    // int logic = not s_instance;

    // SE014: Унарний мінус для char (залишимо цю перевірку, бо це може бути неоднозначно)
    // char negative_char = -c;

    // SE015: Розіменування не-вказівника
    // deref a;

    // SE016: Взяття адреси у літерала
    // addr 100;

    return 0;
}